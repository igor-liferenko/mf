diff --git a/mf.w b/mf.w
index 1953248..f9f28b0 100644
--- a/mf.w
+++ b/mf.w
@@ -911,14 +911,10 @@ consist of the remainder of the command line, after the part that invoked \MF.
 The first line is special also because it may be read before \MF\ has
 input a base file. In such cases, normal error messages cannot yet
 be given. The following code uses concepts that will be explained later.
-(If the \PASCAL\ compiler does not support non-local |@!goto|\unskip, the
-@^system dependencies@>
-statement `|goto exit(0)|' should be replaced by something that
-quietly terminates the program.)
 
 @<Report overflow of the input buffer, and abort@>=
 if (base_ident==0) 
-  {@+write_ln(term_out,"Buffer size exceeded!");exit(0);
+  {@+write_ln(term_out,"Buffer size exceeded!");exit(1);
 @.Buffer size exceeded@>
   } 
 else{@+cur_input.loc_field=first;cur_input.limit_field=last-1;
@@ -1725,15 +1721,9 @@ help_ptr=0;use_err_help=false;err_help=0;
 goes to |end_of_MF|. This is the only nontrivial |@!goto| statement in the
 whole program. It is used when there is no recovery from a particular error.
 
-Some \PASCAL\ compilers do not implement non-local |goto| statements.
-@^system dependencies@>
-In such cases the body of |jump_out| should simply be
-`|close_files_and_terminate|;\thinspace' followed by a call on some system
-procedure that quietly terminates the program.
-
 @<Error hand...@>=
 void jump_out(void)
-{@+ close_files_and_terminate(); exit(0);
+{@+ close_files_and_terminate(); wterm_cr; exit(1);
 } 
 
 @ Here now is the general |error| routine.
@@ -13831,7 +13821,7 @@ param_ptr=0;max_param_stack=0;
 first=1;
 start=1;index=0;line=0;name=0;
 force_eof=false;
-if (!init_terminal()) exit(0);
+if (!init_terminal()) goto final_end;
 limit=last;first=last+1; /*|init_terminal| has set |loc| and |last|*/ 
 } 
 
@@ -22863,7 +22853,7 @@ if (bad > 0)
   {@+wterm_ln("Ouch---my internal constants have been clobbered!"
     "---case %d", bad);
 @.Ouch...clobbered@>
-  exit(0);
+  goto final_end;
   } 
 initialize(); /*set global variables to their starting values*/ 
 #ifdef @!INIT
@@ -22883,8 +22873,10 @@ if (start_sym > 0)  /*insert the `\&{everyjob}' symbol*/
 main_control(); /*come to life*/ 
 final_cleanup(); /*prepare for death*/ 
 close_files_and_terminate();
-ready_already=0;
-return 0; }
+final_end:
+wterm_cr;
+if (history <= warning_issued) return 0;
+else return 1; }
 
 @ Here we do whatever is needed to complete \MF's job gracefully on the
 local operating system. The code here might come into play after a fatal
@@ -23049,9 +23041,9 @@ But when we finish this part of the program, \MF\ is ready to call on the
 {@+@<Initialize the input routines@>;
 if ((base_ident==0)||(buffer[loc]=='&')) 
   {@+if (base_ident!=0) initialize(); /*erase preloaded base*/ 
-  if (!open_base_file()) exit(0);
+  if (!open_base_file()) goto final_end;
   if (!load_base_file()) 
-    {@+w_close(&base_file);exit(0);
+    {@+w_close(&base_file);goto final_end;
     } 
   w_close(&base_file);
   while ((loc < limit)&&(buffer[loc]==' ')) incr(loc);
