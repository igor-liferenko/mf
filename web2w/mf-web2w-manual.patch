diff --git a/web2w/mf.w b/web2w/mf.w
index e07eb8c..918545a 100644
--- a/web2w/mf.w
+++ b/web2w/mf.w
@@ -8822,8 +8822,8 @@
 the presence of rounding errors. Our subroutines
 also obey the identity |t[a, b]+t[b, a]==a+b|.
 
-@d t_of_the_way_end(X)	X,t@=)@>
-@d t_of_the_way(X)	X-take_fraction@=(@>X-t_of_the_way_end
+@d t_of_the_way_end(X)	1
+@d t_of_the_way(X)	t_of_the_way_end
 
 @<Declare the procedure called |split_cubic|@>=
 void split_cubic(pointer @!p, fraction @!t,
@@ -9663,10 +9663,10 @@
 {@+new_boundary(p, right_type(p));s=link(p);
 o1=octant_number[right_type(p)];o2=octant_number[right_type(q)];
 switch (o2-o1) {
-case 1: case -7: case 7: case -1: goto done;
-case 2: case -6: clockwise=false;@+break;
-case 3: case -5: case 4: case -4: case 5: case -3: @<Decide whether or not to go clockwise@>@;@+break;
-case 6: case -2: clockwise=true;@+break;
+case 1: case 7: case 7: case 1: goto done;
+case 2: case 6: clockwise=false;@+break;
+case 3: case 5: case 4: case 4: case 5: case 3: @<Decide whether or not to go clockwise@>@;@+break;
+case 6: case 2: clockwise=true;@+break;
 case 0: clockwise=rev_turns;
 }  /*there are no other cases*/ 
 @<Insert additional boundary nodes, then |goto done|@>;
@@ -10838,13 +10838,6 @@
 respectively.
 
 @<Other local variables for |fill_envelope|@>=
-int @!m, @!n; /*current lattice position*/ 
-int @!mm0, @!mm1; /*skewed equivalents of |m0| and |m1|*/ 
-int @!k; /*current offset number*/ 
-pointer @!w, @!ww; /*pointers to the current offset and its neighbor*/ 
-uint16_t @!smooth_bot, @!smooth_top; /*boundaries of smoothing*/ 
-scaled @!xx, @!yy, @!xp, @!yp, @!delx, @!dely, @!tx, @!ty;
-   /*registers for coordinate calculations*/ 
 
 @ @<Make the envelope moves for the current octant...@>=
 if (odd(octant_number[octant])) 
@@ -10966,6 +10959,13 @@
 void dual_moves(pointer @!h, pointer @!p, pointer @!q)
 {@+
 pointer @!r, @!s; /*for list traversal*/ 
+int @!m, @!n; /*current lattice position*/ 
+int @!mm0, @!mm1; /*skewed equivalents of |m0| and |m1|*/ 
+int @!k; /*current offset number*/ 
+pointer @!w, @!ww; /*pointers to the current offset and its neighbor*/ 
+uint16_t @!smooth_bot, @!smooth_top; /*boundaries of smoothing*/ 
+scaled @!xx, @!yy, @!xp, @!yp, @!delx, @!dely, @!tx, @!ty;
+   /*registers for coordinate calculations*/ 
 @<Other local variables for |fill_envelope|@>@;
 @<Initialize for dual envelope moves@>;
 r=p; /*recall that |right_type(q)==endpoint==0| now*/ 
@@ -12123,7 +12123,6 @@
 @<Types...@>=
 typedef uint16_t screen_row; /*a row number on the screen*/ 
 typedef uint16_t screen_col; /*a column number on the screen*/ 
-typedef screen_col *trans_spec;
 typedef uint8_t pixel_color; /*specifies one of the two pixel values*/ 
 
 @ We'll illustrate the |blank_rectangle| and |paint_row| operations by
@@ -12172,7 +12171,7 @@
 program (see the commented-out code below).
 @^system dependencies@>
 
-@p void paint_row(screen_row @!r, pixel_color @!b, trans_spec @!a,
+@p void paint_row(screen_row @!r, pixel_color @!b,
   screen_col @!n)
 {@+int @!k; /*an index into |a|*/ 
 screen_col @!c; /*an index into |screen_pixel|*/ 
@@ -12181,7 +12180,7 @@
 wlog("Calling PAINTROW(", r: 1, ',' , b: 1, ';' );
    /*this is done only after |init_screen==true|*/ 
 for (k=0; k<=n; k++) 
-  {@+wlog(a[k]);if (k!=n) wlog( ',' );
+  {@+if (k!=n) wlog( ',' );
   } 
 wlog_ln( ')' );
 #endif
@@ -12363,14 +12362,14 @@
 unsorted(p)=empty; /*this time we'll paint, but maybe not next time*/ 
 @<Set up the parameters needed for |paint_row|; but |goto done| if no painting is
 needed after all@>;
-paint_row(r, b, &row_transition, n);
+paint_row(r, b, n);
 done: ;} 
 
 @ The transition-specification parameter to |paint_row| is always the same
 array.
 
 @<Glob...@>=
-trans_spec @!row_transition; /*an array of |black|/|white| transitions*/ 
+ /*an array of |black|/|white| transitions*/ 
 
 @ The job remaining is to go through the list |sorted(p)|, unpacking the
 |info| fields into |m| and weight, then making |black| the pixels whose
@@ -12395,7 +12394,7 @@
 
 @ @<Set up the parameters needed for |paint_row|...@>=
 n=0;ww=0;m=-1;w=0;
-q=sorted(p);row_transition[0]=min_col;
+q=sorted(p);
 loop@+{@+if (q==sentinel) d=right_edge;
   else d=ho(info(q));
   mm=(d/8)+m_adjustment;
@@ -12421,12 +12420,11 @@
         } 
       else b=black;
     else incr(n);
-    row_transition[n]=m;
     } 
   } 
 else if (ww <= 0) if (m > min_col) 
   {@+if (n==0) b=black;
-  incr(n);row_transition[n]=m;
+  incr(n);
   } 
 
 @ If the entire row is |white| in the window area, we can omit painting it
@@ -12441,7 +12439,7 @@
   {@+if (n==0) 
     if (ww > 0) b=black;
     else b=white;
-  incr(n);row_transition[n]=right_col[k];
+  incr(n);
   } 
 else if (n==0) goto done
 
@@ -19129,10 +19127,8 @@
   if (a > l) a=l;
   } 
 str_room(b-a);
-if (reversed)
-  {for (k=str_start[s]+b-1; k>=str_start[s]+a; k--) append_char(so(str_pool[k]));}
-else
-  {for (k=str_start[s]+a; k<=str_start[s]+b-1; k++) append_char(so(str_pool[k]));}
+if (reversed) 
+ for (k=str_start[s]+a; k<=str_start[s]+b-1; k++) append_char(so(str_pool[k]));
 cur_exp=make_string();delete_str_ref(s);
 } 
 
@@ -21202,7 +21198,7 @@
 
 @d cancel_skips(X)	ll=X;
   @/do@+{lll=qo(skip_byte(ll));skip_byte(ll)=stop_flag;ll=ll-lll;
-  }@+ while (!(lll==0))
+  }@+ while (!(lll==0));
 @d skip_error(X)	{@+print_err("Too far to skip");
 @.Too far to skip@>
   help1("At most 127 lig/kern steps can separate skipto1 from 1::.");
