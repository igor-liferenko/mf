--- ../mf.web	2020-04-21 13:36:48.859464798 +0700
+++ mf.web	2020-04-21 13:56:45.992563073 +0700
@@ -7120,13 +7120,13 @@
 The final |link| of the |sorted| list will be |sentinel|, which points to
 a special one-word node whose |info| field is essentially infinite; this
 facilitates the sorting and merging operations. The final |link| of the
-|unsorted| list will be either |null| or |void|, where |void=null+1|
+|unsorted| list will be either |null| or |empty|, where |empty=null+1|
 is used to avoid redisplaying data that has not changed:
-A |void| value is stored at the head of the
+A |empty| value is stored at the head of the
 unsorted list whenever the corresponding row has been displayed.
 
 @d zero_w=4
-@d void==null+1
+@d empty==null+1
 
 @<Initialize table entries...@>=
 info(sentinel):=max_halfword; {|link(sentinel)=null|}
@@ -7178,10 +7178,10 @@
 fields that are called |last_window(h)| and |last_window_time(h)|. When this
 structure is displayed in window~|k| of the user's screen, after that
 window has been updated |t| times, \MF\ sets |last_window(h):=k| and
-|last_window_time(h):=t|; it also sets |unsorted(p):=void| for all row
+|last_window_time(h):=t|; it also sets |unsorted(p):=empty| for all row
 headers~|p|, after merging any existing unsorted weights with the sorted
 ones.  A subsequent display in the same window will be able to avoid
-redisplaying rows whose |unsorted| list is still |void|, if the window
+redisplaying rows whose |unsorted| list is still |empty|, if the window
 hasn't been used for something else in the meantime.
 
 A pointer to the row header of row |n_pos(h)-4096| is provided in
@@ -7244,7 +7244,7 @@
     begin info(p):=info(p)-delta; p:=link(p);
     end;
   p:=unsorted(q);
-  while p>void do
+  while p>empty do
     begin info(p):=info(p)-delta; p:=link(p);
     end;
   q:=link(q);
@@ -7279,7 +7279,7 @@
 @ @<Insert exactly |n_min(cur_edges)-nl| empty rows at the bottom@>=
 begin delta:=n_min(cur_edges)-nl; n_min(cur_edges):=nl;
 p:=link(cur_edges);
-repeat q:=get_node(row_node_size); sorted(q):=sentinel; unsorted(q):=void;
+repeat q:=get_node(row_node_size); sorted(q):=sentinel; unsorted(q):=empty;
 knil(p):=q; link(q):=p; p:=q; decr(delta);
 until delta=0;
 knil(p):=cur_edges; link(cur_edges):=p;
@@ -7289,7 +7289,7 @@
 @ @<Insert exactly |nr-n_max(cur_edges)| empty rows at the top@>=
 begin delta:=nr-n_max(cur_edges); n_max(cur_edges):=nr;
 p:=knil(cur_edges);
-repeat q:=get_node(row_node_size); sorted(q):=sentinel; unsorted(q):=void;
+repeat q:=get_node(row_node_size); sorted(q):=sentinel; unsorted(q):=empty;
 link(p):=q; knil(q):=p; p:=q; decr(delta);
 until delta=0;
 link(p):=cur_edges; knil(cur_edges):=p;
@@ -7309,9 +7309,9 @@
 p:=knil(cur_edges); n:=n_max(cur_edges)-zero_field;
 while p<>cur_edges do
   begin q:=unsorted(p); r:=sorted(p);
-  if(q>void)or(r<>sentinel) then
+  if(q>empty)or(r<>sentinel) then
     begin print_nl("row "); print_int(n+y_off); print_char(":");
-    while q>void do
+    while q>empty do
       begin print_weight(q,x_off); q:=link(q);
       end;
     print(" |");
@@ -7369,7 +7369,7 @@
   end;
 link(rr):=sentinel;@/
 r:=unsorted(p); rr:=temp_head;
-while r>void do
+while r>empty do
   begin ss:=get_avail; link(rr):=ss; rr:=ss; info(rr):=info(r);@/
   r:=link(r);
   end;
@@ -7415,7 +7415,7 @@
 
 @<Reflect the edge-and-weight data in |unsorted(p)|@>=
 q:=unsorted(p);
-while q>void do
+while q>empty do
   begin info(q):=m-info(q); q:=link(q);
   end
 
@@ -7497,7 +7497,7 @@
   begin t:=ho(info(p)); w:=t mod 8; info(p):=(t-w)*s+w+delta; p:=link(p);
   end;
 p:=unsorted(q);
-while p>void do
+while p>empty do
   begin t:=ho(info(p)); w:=t mod 8; info(p):=(t-w)*s+w+delta; p:=link(p);
   end;
 q:=link(q);
@@ -7512,7 +7512,7 @@
 begin p:=link(h);
 while p<>h do
   begin q:=unsorted(p);
-  while q>void do
+  while q>empty do
     begin info(q):=8-2*((ho(info(q))) mod 8)+info(q); q:=link(q);
     end;
   q:=sorted(p);
@@ -7556,7 +7556,7 @@
 @!p,@!q,@!r,@!s:pointer;
 begin r:=unsorted(h); unsorted(h):=null;
 p:=link(r); link(r):=sentinel; link(temp_head):=r;
-while p>void do {sort node |p| into the list that starts at |temp_head|}
+while p>empty do {sort node |p| into the list that starts at |temp_head|}
   begin k:=info(p); q:=temp_head;
   repeat r:=q; q:=link(r);
   until k<=info(q);
@@ -7605,7 +7605,7 @@
 min_n:=max_halfword; max_n:=min_halfword;@/
 p:=link(cur_edges); n:=n_min(cur_edges);
 while p<>cur_edges do
-  begin if unsorted(p)>void then sort_edges(p);
+  begin if unsorted(p)>empty then sort_edges(p);
   if sorted(p)<>sentinel then
     @<Cull superfluous edge-weight entries from |sorted(p)|@>;
   p:=link(p); incr(n);
@@ -7716,7 +7716,7 @@
 begin @<Initialize the array of new edge list heads@>;
 @<Insert blank rows at the top and bottom, and set |p| to the new top row@>;
 @<Compute the magic offset values@>;
-repeat q:=knil(p);@+if unsorted(q)>void then sort_edges(q);
+repeat q:=knil(p);@+if unsorted(q)>empty then sort_edges(q);
 @<Insert the horizontal edges defined by adjacent rows |p,q|,
   and destroy row~|p|@>;
 p:=q; n_magic:=n_magic-8;
@@ -7879,7 +7879,7 @@
   begin info(qq):=info(qq)+delta; qq:=link(qq);
   end;
 qq:=unsorted(pp);
-while qq>void do
+while qq>empty do
   begin info(qq):=info(qq)+delta; qq:=link(qq);
   end;
 pp:=link(pp);
@@ -7892,14 +7892,14 @@
 
 @<Merge row |pp|...@>=
 qq:=unsorted(pp);
-if qq>void then
-  if unsorted(p)<=void then unsorted(p):=qq
-  else  begin while link(qq)>void do qq:=link(qq);
+if qq>empty then
+  if unsorted(p)<=empty then unsorted(p):=qq
+  else  begin while link(qq)>empty do qq:=link(qq);
     link(qq):=unsorted(p); unsorted(p):=unsorted(pp);
     end;
 unsorted(pp):=null; qq:=sorted(pp);
 if qq<>sentinel then
-  begin if unsorted(p)=void then unsorted(p):=null;
+  begin if unsorted(p)=empty then unsorted(p):=null;
   sorted(pp):=sentinel; r:=sorted_loc(p); q:=link(r); {|q=sorted(p)|}
   if q=sentinel then sorted(p):=qq
   else loop@+begin k:=info(qq);
@@ -7934,7 +7934,7 @@
     @<Add the contribution of node |q| to the total weight,
       and set |q:=link(q)|@>;
   q:=unsorted(p);
-  while q>void do
+  while q>empty do
     @<Add the contribution of node |q| to the total weight,
       and set |q:=link(q)|@>;
   p:=link(p);
@@ -8247,7 +8247,7 @@
 begin q:=link(h);
 while q<>h do
   begin flush_list(sorted(q));
-  if unsorted(q)>void then flush_list(unsorted(q));
+  if unsorted(q)>empty then flush_list(unsorted(q));
   p:=q; q:=link(q); free_node(p,row_node_size);
   end;
 free_node(h,edge_header_size);
@@ -8815,8 +8815,8 @@
 the presence of rounding errors. Our subroutines
 also obey the identity |t[a,b]+t[b,a]=a+b|.
 
-@d t_of_the_way_end(#)==#,t@=)@>
-@d t_of_the_way(#)==#-take_fraction@=(@>#-t_of_the_way_end
+@d t_of_the_way_end(#)==1
+@d t_of_the_way(#)==t_of_the_way_end
 
 @<Declare the procedure called |split_cubic|@>=
 procedure split_cubic(@!p:pointer;@!t:fraction;
@@ -9660,10 +9660,10 @@
 begin new_boundary(p,right_type(p)); s:=link(p);
 o1:=octant_number[right_type(p)]; o2:=octant_number[right_type(q)];
 case o2-o1 of
-1,-7,7,-1: goto done;
-2,-6: clockwise:=false;
-3,-5,4,-4,5,-3: @<Decide whether or not to go clockwise@>;
-6,-2: clockwise:=true;
+1,7,7,1: goto done;
+2,6: clockwise:=false;
+3,5,4,4,5,3: @<Decide whether or not to go clockwise@>;
+6,2: clockwise:=true;
 0:clockwise:=rev_turns;
 end; {there are no other cases}
 @<Insert additional boundary nodes, then |goto done|@>;
@@ -10835,13 +10835,6 @@
 respectively.
 
 @<Other local variables for |fill_envelope|@>=
-@!m,@!n:integer; {current lattice position}
-@!mm0,@!mm1:integer; {skewed equivalents of |m0| and |m1|}
-@!k:integer; {current offset number}
-@!w,@!ww:pointer; {pointers to the current offset and its neighbor}
-@!smooth_bot,@!smooth_top:0..move_size; {boundaries of smoothing}
-@!xx,@!yy,@!xp,@!yp,@!delx,@!dely,@!tx,@!ty:scaled;
-  {registers for coordinate calculations}
 
 @ @<Make the envelope moves for the current octant...@>=
 if odd(octant_number[octant]) then
@@ -10954,6 +10947,13 @@
 procedure dual_moves(@!h,@!p,@!q:pointer);
 label done,done1;
 var @!r,@!s:pointer; {for list traversal}
+@!m,@!n:integer; {current lattice position}
+@!mm0,@!mm1:integer; {skewed equivalents of |m0| and |m1|}
+@!k:integer; {current offset number}
+@!w,@!ww:pointer; {pointers to the current offset and its neighbor}
+@!smooth_bot,@!smooth_top:0..move_size; {boundaries of smoothing}
+@!xx,@!yy,@!xp,@!yp,@!delx,@!dely,@!tx,@!ty:scaled;
+  {registers for coordinate calculations}
 @<Other local variables for |fill_envelope|@>@;
 begin @<Initialize for dual envelope moves@>;
 r:=p; {recall that |right_type(q)=endpoint=0| now}
@@ -12103,7 +12103,6 @@
 @<Types...@>=
 @!screen_row=0..screen_depth; {a row number on the screen}
 @!screen_col=0..screen_width; {a column number on the screen}
-@!trans_spec=array[screen_col] of screen_col; {a transition spec, see below}
 @!pixel_color=white..black; {specifies one of the two pixel values}
 
 @ We'll illustrate the |blank_rectangle| and |paint_row| operations by
@@ -12131,7 +12130,7 @@
 @!c:screen_col;
 begin @{@+for r:=top_row to bot_row-1 do
   for c:=left_col to right_col-1 do
-    screen_pixel[r,c]:=white;@+@}@/
+    screen_pixel[r]:=white;@+@}@/
 @!init wlog_cr; {this will be done only after |init_screen=true|}
 wlog_ln('Calling BLANKRECTANGLE(',left_col:1,',',
   right_col:1,',',top_row:1,',',bot_row:1,')');@+tini
@@ -12152,14 +12151,14 @@
 program (see the commented-out code below).
 @^system dependencies@>
 
-@p procedure paint_row(@!r:screen_row;@!b:pixel_color;var @!a:trans_spec;
+@p procedure paint_row(@!r:screen_row;@!b:pixel_color;var @!a:integerl;
   @!n:screen_col);
 var @!k:screen_col; {an index into |a|}
 @!c:screen_col; {an index into |screen_pixel|}
-begin @{ k:=0; c:=a[0];
+begin @{ k:=0; c:=a;
 repeat incr(k);
-  repeat screen_pixel[r,c]:=b; incr(c);
-  until c=a[k];
+  repeat screen_pixel[r]:=b; incr(c);
+  until c=a;
   b:=black-b; {$|black|\swap|white|$}
   until k=n;@+@}@/
 @!init wlog('Calling PAINTROW(',r:1,',',b:1,';');
@@ -12342,9 +12341,9 @@
 whenever we can.
 
 @<Display the pixels of edge row |p| in screen row |r|@>=
-begin if unsorted(p)>void then sort_edges(p)
-else if unsorted(p)=void then if already_there then goto done;
-unsorted(p):=void; {this time we'll paint, but maybe not next time}
+begin if unsorted(p)>empty then sort_edges(p)
+else if unsorted(p)=empty then if already_there then goto done;
+unsorted(p):=empty; {this time we'll paint, but maybe not next time}
 @<Set up the parameters needed for |paint_row|;
   but |goto done| if no painting is needed after all@>;
 paint_row(r,b,row_transition,n);
@@ -12354,7 +12353,7 @@
 array.
 
 @<Glob...@>=
-@!row_transition:trans_spec; {an array of |black|/|white| transitions}
+@!row_transition:array[screen_col] of screen_col; {an array of |black|/|white| transitions}
 
 @ The job remaining is to go through the list |sorted(p)|, unpacking the
 |info| fields into |m| and weight, then making |black| the pixels whose
@@ -13524,13 +13523,13 @@
 @ The parameter that corresponds to a loop text is either a token list
 (in the case of \&{forsuffixes}) or a ``capsule'' (in the case of \&{for}).
 We'll discuss capsules later; for now, all we need to know is that
-the |link| field in a capsule parameter is |void| and that
+the |link| field in a capsule parameter is |empty| and that
 |print_exp(p,0)| displays the value of capsule~|p| in abbreviated form.
 
 @<Print the current loop value@>=
 begin print_nl("<for("); p:=param_stack[param_start];
 if p<>null then
-  if link(p)=void then print_exp(p,0) {we're in a \&{for} loop}
+  if link(p)=empty then print_exp(p,0) {we're in a \&{for} loop}
   else show_token_list(p,null,20,tally);
 print(")> ");
 end
@@ -13691,7 +13690,7 @@
   begin decr(param_ptr);
   p:=param_stack[param_ptr];
   if p<>null then
-    if link(p)=void then {it's an \&{expr} parameter}
+    if link(p)=empty then {it's an \&{expr} parameter}
       begin recycle_value(p); free_node(p,value_node_size);
       end
     else flush_token_list(p); {it's a \&{suffix} or \&{text} parameter}
@@ -14775,7 +14774,7 @@
 
 Arguments of type \&{expr} are so-called capsules, which we will
 discuss later when we concentrate on expressions; they can be
-recognized easily because their |link| field is |void|. Arguments of type
+recognized easily because their |link| field is |empty|. Arguments of type
 \&{suffix} and \&{text} are token lists without reference counts.
 
 @ After argument scanning is complete, the arguments are moved to the
@@ -14839,11 +14838,11 @@
 
 @ @<Declare the procedure called |print_arg|@>=
 procedure print_arg(@!q:pointer;@!n:integer;@!b:pointer);
-begin if link(q)=void then print_nl("(EXPR")
+begin if link(q)=empty then print_nl("(EXPR")
 else if (b<text_base)and(b<>text_macro) then print_nl("(SUFFIX")
 else print_nl("(TEXT");
 print_int(n); print(")<-");
-if link(q)=void then print_exp(q,1)
+if link(q)=empty then print_exp(q,1)
 else show_token_list(q,null,1000,0);
 end;
 
@@ -15284,10 +15283,10 @@
 points to a list of one-word nodes whose |info| fields point to the
 remaining argument values of a suffix list and expression list.
 
-\yskip\indent|loop_type(loop_ptr)=void| means that the current loop is
+\yskip\indent|loop_type(loop_ptr)=empty| means that the current loop is
 `\&{forever}'.
 
-\yskip\indent|loop_type(loop_ptr)=p>void| means that |value(p)|,
+\yskip\indent|loop_type(loop_ptr)=p>empty| means that |value(p)|,
 |step_size(p)|, and |final_value(p)| contain the data for an arithmetic
 progression.
 
@@ -15337,7 +15336,7 @@
 @!p,@!q,@!s,@!pp:pointer; {link manipulation registers}
 begin m:=cur_mod; n:=cur_sym; s:=get_node(loop_node_size);
 if m=start_forever then
-  begin loop_type(s):=void; p:=null; get_x_next; goto found;
+  begin loop_type(s):=empty; p:=null; get_x_next; goto found;
   end;
 get_symbol; p:=get_node(token_node_size); info(p):=cur_sym; value(p):=m;@/
 get_x_next;
@@ -15391,13 +15390,13 @@
 label not_found,exit;
 var @!p,@!q:pointer; {link registers}
 begin p:=loop_type(loop_ptr);
-if p>void then {|p| points to a progression node}
+if p>empty then {|p| points to a progression node}
   begin cur_exp:=value(p);
   if @<The arithmetic progression has ended@> then goto not_found;
   cur_type:=known; q:=stash_cur_exp; {make |q| an \&{expr} argument}
   value(p):=cur_exp+step_size(p); {set |value(p)| for the next iteration}
   end
-else if p<void then
+else if p<empty then
   begin p:=loop_list(loop_ptr);
   if p=null then goto not_found;
   loop_list(loop_ptr):=link(p); q:=info(p); free_avail(p);
@@ -15418,7 +15417,7 @@
 @ @<Trace the start of a loop@>=
 begin begin_diagnostic; print_nl("{loop value=");
 @.loop value=n@>
-if (q<>null)and(link(q)=void) then print_exp(q,1)
+if (q<>null)and(link(q)=empty) then print_exp(q,1)
 else show_token_list(q,null,50,0);
 print_char("}"); end_diagnostic(false);
 end
@@ -15430,13 +15429,13 @@
 @p procedure stop_iteration;
 var @!p,@!q:pointer; {the usual}
 begin p:=loop_type(loop_ptr);
-if p>void then free_node(p,progression_node_size)
-else if p<void then
+if p>empty then free_node(p,progression_node_size)
+else if p<empty then
   begin q:=loop_list(loop_ptr);
   while q<>null do
     begin p:=info(q);
     if p<>null then
-      if link(p)=void then {it's an \&{expr} parameter}
+      if link(p)=empty then {it's an \&{expr} parameter}
         begin recycle_value(p); free_node(p,value_node_size);
         end
       else flush_token_list(p); {it's a \&{suffix} or \&{text} parameter}
@@ -16129,7 +16128,7 @@
 @ Capsules are two-word nodes that have a similar meaning
 to |cur_type| and |cur_exp|. Such nodes have |name_type=capsule|,
 and their |type| field is one of the possibilities for |cur_type| listed above.
-Also |link<=void| in capsules that aren't part of a token list.
+Also |link<=empty| in capsules that aren't part of a token list.
 
 The |value| field of a capsule is, in most cases, the value that
 corresponds to its |type|, as |cur_exp| corresponds to |cur_type|.
@@ -16157,7 +16156,7 @@
 After the operation, |cur_type=vacuous|; hence there is no need to
 copy path lists or to update reference counts, etc.
 
-The special link |void| is put on the capsule returned by
+The special link |empty| is put on the capsule returned by
 |stash_cur_exp|, because this procedure is used to store macro parameters
 that must be easily distinguishable from token lists.
 
@@ -16171,7 +16170,7 @@
   type(p):=cur_type; value(p):=cur_exp;
   end
 endcases;@/
-cur_type:=vacuous; link(p):=void; stash_cur_exp:=p;
+cur_type:=vacuous; link(p):=empty; stash_cur_exp:=p;
 end;
 
 @ The inverse of |stash_cur_exp| is the following procedure, which
@@ -16316,7 +16315,7 @@
 print_nl(">> ");
 @.>>@>
 print_exp(p,1); {``medium verbose'' printing of the expression}
-if s<>"" then
+if interaction<>error_stop_mode then
   begin print_nl("! "); print(s);
 @.!\relax@>
   end;
@@ -18349,7 +18348,7 @@
 @<Sidestep |independent| cases in capsule |p|@>=
 case type(p) of
 transform_type,pair_type: old_p:=tarnished(p);
-independent: old_p:=void;
+independent: old_p:=empty;
 othercases old_p:=null
 endcases;
 if old_p<>null then
@@ -18360,7 +18359,7 @@
 @ @<Sidestep |independent| cases in the current expression@>=
 case cur_type of
 transform_type,pair_type:old_exp:=tarnished(cur_exp);
-independent:old_exp:=void;
+independent:old_exp:=empty;
 othercases old_exp:=null
 endcases;
 if old_exp<>null then
@@ -18375,7 +18374,7 @@
 begin q:=value(p); r:=q+big_node_size[type(p)];
 repeat r:=r-2;
 if type(r)=independent then
-  begin tarnished:=void; return;
+  begin tarnished:=empty; return;
   end;
 until r=q;
 tarnished:=null;
@@ -18628,7 +18627,7 @@
   @<Trace the fraction multiplication@>;
 case cur_type of
 transform_type,pair_type:old_exp:=tarnished(cur_exp);
-independent:old_exp:=void;
+independent:old_exp:=empty;
 othercases old_exp:=null
 endcases;
 if old_exp<>null then
@@ -19136,8 +19135,7 @@
   end;
 str_room(b-a);
 if reversed then
-  for k:=str_start[s]+b-1 downto str_start[s]+a do append_char(so(str_pool[k]))
-else for k:=str_start[s]+a to str_start[s]+b-1 do append_char(so(str_pool[k]));
+ for k:=str_start[s]+a to str_start[s]+b-1 do append_char(so(str_pool[k]));
 cur_exp:=make_string; delete_str_ref(s);
 end;
 
@@ -21206,7 +21204,7 @@
 
 @d cancel_skips(#)==ll:=#;
   repeat lll:=qo(skip_byte(ll)); skip_byte(ll):=stop_flag; ll:=ll-lll;
-  until lll=0
+  until lll=0;
 @d skip_error(#)==begin print_err("Too far to skip");
 @.Too far to skip@>
   help1("At most 127 lig/kern steps can separate skipto1 from 1::.");
@@ -22343,7 +22341,7 @@
 look ahead to column~|mm| before actually outputting anything.
 
 @<Output the pixels of edge row |p| to font row |n|@>=
-if unsorted(p)>void then sort_edges(p);
+if unsorted(p)>empty then sort_edges(p);
 q:=sorted(p); w:=0; prev_m:=-fraction_one; {$|fraction_one|\approx\infty$}
 ww:=0; prev_w:=0; m:=prev_m;
 repeat if q=sentinel then mm:=fraction_one
