diff --git a/web2w/mf.web b/web2w/mf.web
index ca3cb25..b9d61e5 100644
--- a/web2w/mf.web
+++ b/web2w/mf.web
@@ -7120,13 +7120,13 @@ row has not changed since the last time we sorted it.
 The final |link| of the |sorted| list will be |sentinel|, which points to
 a special one-word node whose |info| field is essentially infinite; this
 facilitates the sorting and merging operations. The final |link| of the
-|unsorted| list will be either |null| or |void|, where |void=null+1|
+|unsorted| list will be either |null| or |empty|, where |empty=null+1|
 is used to avoid redisplaying data that has not changed:
-A |void| value is stored at the head of the
+A |empty| value is stored at the head of the
 unsorted list whenever the corresponding row has been displayed.
 
 @d zero_w=4
-@d void==null+1
+@d empty==null+1
 
 @<Initialize table entries...@>=
 info(sentinel):=max_halfword; {|link(sentinel)=null|}
@@ -7178,10 +7178,10 @@ The header node of an edge structure also contains two somewhat unusual
 fields that are called |last_window(h)| and |last_window_time(h)|. When this
 structure is displayed in window~|k| of the user's screen, after that
 window has been updated |t| times, \MF\ sets |last_window(h):=k| and
-|last_window_time(h):=t|; it also sets |unsorted(p):=void| for all row
+|last_window_time(h):=t|; it also sets |unsorted(p):=empty| for all row
 headers~|p|, after merging any existing unsorted weights with the sorted
 ones.  A subsequent display in the same window will be able to avoid
-redisplaying rows whose |unsorted| list is still |void|, if the window
+redisplaying rows whose |unsorted| list is still |empty|, if the window
 hasn't been used for something else in the meantime.
 
 A pointer to the row header of row |n_pos(h)-4096| is provided in
@@ -7244,7 +7244,7 @@ while q<>cur_edges do
     begin info(p):=info(p)-delta; p:=link(p);
     end;
   p:=unsorted(q);
-  while p>void do
+  while p>empty do
     begin info(p):=info(p)-delta; p:=link(p);
     end;
   q:=link(q);
@@ -7279,7 +7279,7 @@ end;
 @ @<Insert exactly |n_min(cur_edges)-nl| empty rows at the bottom@>=
 begin delta:=n_min(cur_edges)-nl; n_min(cur_edges):=nl;
 p:=link(cur_edges);
-repeat q:=get_node(row_node_size); sorted(q):=sentinel; unsorted(q):=void;
+repeat q:=get_node(row_node_size); sorted(q):=sentinel; unsorted(q):=empty;
 knil(p):=q; link(q):=p; p:=q; decr(delta);
 until delta=0;
 knil(p):=cur_edges; link(cur_edges):=p;
@@ -7289,7 +7289,7 @@ end
 @ @<Insert exactly |nr-n_max(cur_edges)| empty rows at the top@>=
 begin delta:=nr-n_max(cur_edges); n_max(cur_edges):=nr;
 p:=knil(cur_edges);
-repeat q:=get_node(row_node_size); sorted(q):=sentinel; unsorted(q):=void;
+repeat q:=get_node(row_node_size); sorted(q):=sentinel; unsorted(q):=empty;
 link(p):=q; knil(q):=p; p:=q; decr(delta);
 until delta=0;
 link(p):=cur_edges; knil(cur_edges):=p;
@@ -7309,9 +7309,9 @@ begin print_diagnostic("Edge structure",s,nuline);
 p:=knil(cur_edges); n:=n_max(cur_edges)-zero_field;
 while p<>cur_edges do
   begin q:=unsorted(p); r:=sorted(p);
-  if(q>void)or(r<>sentinel) then
+  if(q>empty)or(r<>sentinel) then
     begin print_nl("row "); print_int(n+y_off); print_char(":");
-    while q>void do
+    while q>empty do
       begin print_weight(q,x_off); q:=link(q);
       end;
     print(" |");
@@ -7369,7 +7369,7 @@ while r<>sentinel do
   end;
 link(rr):=sentinel;@/
 r:=unsorted(p); rr:=temp_head;
-while r>void do
+while r>empty do
   begin ss:=get_avail; link(rr):=ss; rr:=ss; info(rr):=info(r);@/
   r:=link(r);
   end;
@@ -7415,7 +7415,7 @@ one without the other.
 
 @<Reflect the edge-and-weight data in |unsorted(p)|@>=
 q:=unsorted(p);
-while q>void do
+while q>empty do
   begin info(q):=m-info(q); q:=link(q);
   end
 
@@ -7497,7 +7497,7 @@ while p<>sentinel do
   begin t:=ho(info(p)); w:=t mod 8; info(p):=(t-w)*s+w+delta; p:=link(p);
   end;
 p:=unsorted(q);
-while p>void do
+while p>empty do
   begin t:=ho(info(p)); w:=t mod 8; info(p):=(t-w)*s+w+delta; p:=link(p);
   end;
 q:=link(q);
@@ -7512,7 +7512,7 @@ var @!p,@!q,@!r,@!s,@!t,@!u:pointer; {structure traversers}
 begin p:=link(h);
 while p<>h do
   begin q:=unsorted(p);
-  while q>void do
+  while q>empty do
     begin info(q):=8-2*((ho(info(q))) mod 8)+info(q); q:=link(q);
     end;
   q:=sorted(p);
@@ -7556,7 +7556,7 @@ var @!k:halfword; {key register that we compare to |info(q)|}
 @!p,@!q,@!r,@!s:pointer;
 begin r:=unsorted(h); unsorted(h):=null;
 p:=link(r); link(r):=sentinel; link(temp_head):=r;
-while p>void do {sort node |p| into the list that starts at |temp_head|}
+while p>empty do {sort node |p| into the list that starts at |temp_head|}
   begin k:=info(p); q:=temp_head;
   repeat r:=q; q:=link(r);
   until k<=info(q);
@@ -7605,7 +7605,7 @@ begin min_d:=max_halfword; max_d:=min_halfword;
 min_n:=max_halfword; max_n:=min_halfword;@/
 p:=link(cur_edges); n:=n_min(cur_edges);
 while p<>cur_edges do
-  begin if unsorted(p)>void then sort_edges(p);
+  begin if unsorted(p)>empty then sort_edges(p);
   if sorted(p)<>sentinel then
     @<Cull superfluous edge-weight entries from |sorted(p)|@>;
   p:=link(p); incr(n);
@@ -7716,7 +7716,7 @@ var @!m_magic,@!n_magic:integer; {special values that account for offsets}
 begin @<Initialize the array of new edge list heads@>;
 @<Insert blank rows at the top and bottom, and set |p| to the new top row@>;
 @<Compute the magic offset values@>;
-repeat q:=knil(p);@+if unsorted(q)>void then sort_edges(q);
+repeat q:=knil(p);@+if unsorted(q)>empty then sort_edges(q);
 @<Insert the horizontal edges defined by adjacent rows |p,q|,
   and destroy row~|p|@>;
 p:=q; n_magic:=n_magic-8;
@@ -7879,7 +7879,7 @@ while qq<>sentinel do
   begin info(qq):=info(qq)+delta; qq:=link(qq);
   end;
 qq:=unsorted(pp);
-while qq>void do
+while qq>empty do
   begin info(qq):=info(qq)+delta; qq:=link(qq);
   end;
 pp:=link(pp);
@@ -7892,14 +7892,14 @@ been merged into row~|p|.
 
 @<Merge row |pp|...@>=
 qq:=unsorted(pp);
-if qq>void then
-  if unsorted(p)<=void then unsorted(p):=qq
-  else  begin while link(qq)>void do qq:=link(qq);
+if qq>empty then
+  if unsorted(p)<=empty then unsorted(p):=qq
+  else  begin while link(qq)>empty do qq:=link(qq);
     link(qq):=unsorted(p); unsorted(p):=unsorted(pp);
     end;
 unsorted(pp):=null; qq:=sorted(pp);
 if qq<>sentinel then
-  begin if unsorted(p)=void then unsorted(p):=null;
+  begin if unsorted(p)=empty then unsorted(p):=null;
   sorted(pp):=sentinel; r:=sorted_loc(p); q:=link(r); {|q=sorted(p)|}
   if q=sentinel then sorted(p):=qq
   else loop@+begin k:=info(qq);
@@ -7934,7 +7934,7 @@ while p<>h do
     @<Add the contribution of node |q| to the total weight,
       and set |q:=link(q)|@>;
   q:=unsorted(p);
-  while q>void do
+  while q>empty do
     @<Add the contribution of node |q| to the total weight,
       and set |q:=link(q)|@>;
   p:=link(p);
@@ -8247,7 +8247,7 @@ var @!p,@!q:pointer; {for list manipulation}
 begin q:=link(h);
 while q<>h do
   begin flush_list(sorted(q));
-  if unsorted(q)>void then flush_list(unsorted(q));
+  if unsorted(q)>empty then flush_list(unsorted(q));
   p:=q; q:=link(q); free_node(p,row_node_size);
   end;
 free_node(h,edge_header_size);
@@ -8815,8 +8815,8 @@ If |0<=t<=1|, the quantity |t[a,b]| is always between |a| and~|b|, even in
 the presence of rounding errors. Our subroutines
 also obey the identity |t[a,b]+t[b,a]=a+b|.
 
-@d t_of_the_way_end(#)==#,t@=)@>
-@d t_of_the_way(#)==#-take_fraction@=(@>#-t_of_the_way_end
+@d t_of_the_way_end(#)==1
+@d t_of_the_way(#)==t_of_the_way_end
 
 @<Declare the procedure called |split_cubic|@>=
 procedure split_cubic(@!p:pointer;@!t:fraction;
@@ -9660,10 +9660,10 @@ expected to understand why.
 begin new_boundary(p,right_type(p)); s:=link(p);
 o1:=octant_number[right_type(p)]; o2:=octant_number[right_type(q)];
 case o2-o1 of
-1,-7,7,-1: goto done;
-2,-6: clockwise:=false;
-3,-5,4,-4,5,-3: @<Decide whether or not to go clockwise@>;
-6,-2: clockwise:=true;
+1,7,7,1: goto done;
+2,6: clockwise:=false;
+3,5,4,4,5,3: @<Decide whether or not to go clockwise@>;
+6,2: clockwise:=true;
 0:clockwise:=rev_turns;
 end; {there are no other cases}
 @<Insert additional boundary nodes, then |goto done|@>;
@@ -10835,13 +10835,6 @@ the final offset adjustments are stored in |smooth_bot| and |smooth_top|,
 respectively.
 
 @<Other local variables for |fill_envelope|@>=
-@!m,@!n:integer; {current lattice position}
-@!mm0,@!mm1:integer; {skewed equivalents of |m0| and |m1|}
-@!k:integer; {current offset number}
-@!w,@!ww:pointer; {pointers to the current offset and its neighbor}
-@!smooth_bot,@!smooth_top:0..move_size; {boundaries of smoothing}
-@!xx,@!yy,@!xp,@!yp,@!delx,@!dely,@!tx,@!ty:scaled;
-  {registers for coordinate calculations}
 
 @ @<Make the envelope moves for the current octant...@>=
 if odd(octant_number[octant]) then
@@ -10954,6 +10947,13 @@ because some \PASCAL\ compilers cannot handle procedures as large as
 procedure dual_moves(@!h,@!p,@!q:pointer);
 label done,done1;
 var @!r,@!s:pointer; {for list traversal}
+@!m,@!n:integer; {current lattice position}
+@!mm0,@!mm1:integer; {skewed equivalents of |m0| and |m1|}
+@!k:integer; {current offset number}
+@!w,@!ww:pointer; {pointers to the current offset and its neighbor}
+@!smooth_bot,@!smooth_top:0..move_size; {boundaries of smoothing}
+@!xx,@!yy,@!xp,@!yp,@!delx,@!dely,@!tx,@!ty:scaled;
+  {registers for coordinate calculations}
 @<Other local variables for |fill_envelope|@>@;
 begin @<Initialize for dual envelope moves@>;
 r:=p; {recall that |right_type(q)=endpoint=0| now}
@@ -12103,7 +12103,6 @@ system for which |white| was black and |black| was bright green.
 @<Types...@>=
 @!screen_row=0..screen_depth; {a row number on the screen}
 @!screen_col=0..screen_width; {a column number on the screen}
-@!trans_spec=array[screen_col] of screen_col; {a transition spec, see below}
 @!pixel_color=white..black; {specifies one of the two pixel values}
 
 @ We'll illustrate the |blank_rectangle| and |paint_row| operations by
@@ -12111,7 +12110,6 @@ pretending to declare a screen buffer called |screen_pixel|. This code
 is actually commented out, but it does specify the intended effects.
 
 @<Glob...@>=
-@{@!screen_pixel:array[screen_row,screen_col] of pixel_color;@+@}
 
 @ The |blank_rectangle| routine simply whitens all pixels that lie in
 columns |left_col| through |right_col-1|, inclusive, of rows
@@ -12129,9 +12127,7 @@ purposes only.
   @!top_row,@!bot_row:screen_row);
 var @!r:screen_row;
 @!c:screen_col;
-begin @{@+for r:=top_row to bot_row-1 do
-  for c:=left_col to right_col-1 do
-    screen_pixel[r,c]:=white;@+@}@/
+begin @/
 @!init wlog_cr; {this will be done only after |init_screen=true|}
 wlog_ln('Calling BLANKRECTANGLE(',left_col:1,',',
   right_col:1,',',top_row:1,',',bot_row:1,')');@+tini
@@ -12152,16 +12148,11 @@ the precise details are best conveyed by means of a \PASCAL\
 program (see the commented-out code below).
 @^system dependencies@>
 
-@p procedure paint_row(@!r:screen_row;@!b:pixel_color;var @!a:trans_spec;
+@p procedure paint_row(@!r:screen_row;@!b:pixel_color;
   @!n:screen_col);
 var @!k:screen_col; {an index into |a|}
 @!c:screen_col; {an index into |screen_pixel|}
-begin @{ k:=0; c:=a[0];
-repeat incr(k);
-  repeat screen_pixel[r,c]:=b; incr(c);
-  until c=a[k];
-  b:=black-b; {$|black|\swap|white|$}
-  until k=n;@+@}@/
+begin @/
 @!init wlog('Calling PAINTROW(',r:1,',',b:1,';');
   {this is done only after |init_screen=true|}
 for k:=0 to n do
@@ -12342,19 +12333,19 @@ end;
 whenever we can.
 
 @<Display the pixels of edge row |p| in screen row |r|@>=
-begin if unsorted(p)>void then sort_edges(p)
-else if unsorted(p)=void then if already_there then goto done;
-unsorted(p):=void; {this time we'll paint, but maybe not next time}
+begin if unsorted(p)>empty then sort_edges(p)
+else if unsorted(p)=empty then if already_there then goto done;
+unsorted(p):=empty; {this time we'll paint, but maybe not next time}
 @<Set up the parameters needed for |paint_row|;
   but |goto done| if no painting is needed after all@>;
-paint_row(r,b,row_transition,n);
+paint_row(r,b,n);
 done: end
 
 @ The transition-specification parameter to |paint_row| is always the same
 array.
 
 @<Glob...@>=
-@!row_transition:trans_spec; {an array of |black|/|white| transitions}
+{an array of |black|/|white| transitions}
 
 @ The job remaining is to go through the list |sorted(p)|, unpacking the
 |info| fields into |m| and weight, then making |black| the pixels whose
@@ -12379,7 +12370,7 @@ min_col:=left_col[k]
 
 @ @<Set up the parameters needed for |paint_row|...@>=
 n:=0; ww:=0; m:=-1; w:=0;
-q:=sorted(p); row_transition[0]:=min_col;
+q:=sorted(p);
 loop@+  begin if q=sentinel then d:=right_edge
   else d:=ho(info(q));
   mm:=(d div 8)+m_adjustment;
@@ -12405,12 +12396,11 @@ if w<=0 then
         end
       else b:=black
     else incr(n);
-    row_transition[n]:=m;
     end;
   end
 else if ww<=0 then if m>min_col then
   begin if n=0 then b:=black;
-  incr(n); row_transition[n]:=m;
+  incr(n);
   end
 
 @ If the entire row is |white| in the window area, we can omit painting it
@@ -12425,7 +12415,7 @@ if already_there or(ww>0) then
   begin if n=0 then
     if ww>0 then b:=black
     else b:=white;
-  incr(n); row_transition[n]:=right_col[k];
+  incr(n);
   end
 else if n=0 then goto done
 
@@ -13524,13 +13514,13 @@ endcases
 @ The parameter that corresponds to a loop text is either a token list
 (in the case of \&{forsuffixes}) or a ``capsule'' (in the case of \&{for}).
 We'll discuss capsules later; for now, all we need to know is that
-the |link| field in a capsule parameter is |void| and that
+the |link| field in a capsule parameter is |empty| and that
 |print_exp(p,0)| displays the value of capsule~|p| in abbreviated form.
 
 @<Print the current loop value@>=
 begin print_nl("<for("); p:=param_stack[param_start];
 if p<>null then
-  if link(p)=void then print_exp(p,0) {we're in a \&{for} loop}
+  if link(p)=empty then print_exp(p,0) {we're in a \&{for} loop}
   else show_token_list(p,null,20,tally);
 print(")> ");
 end
@@ -13691,7 +13681,7 @@ while param_ptr>param_start do {parameters must be flushed}
   begin decr(param_ptr);
   p:=param_stack[param_ptr];
   if p<>null then
-    if link(p)=void then {it's an \&{expr} parameter}
+    if link(p)=empty then {it's an \&{expr} parameter}
       begin recycle_value(p); free_node(p,value_node_size);
       end
     else flush_token_list(p); {it's a \&{suffix} or \&{text} parameter}
@@ -14775,7 +14765,7 @@ further arguments (if any).
 
 Arguments of type \&{expr} are so-called capsules, which we will
 discuss later when we concentrate on expressions; they can be
-recognized easily because their |link| field is |void|. Arguments of type
+recognized easily because their |link| field is |empty|. Arguments of type
 \&{suffix} and \&{text} are token lists without reference counts.
 
 @ After argument scanning is complete, the arguments are moved to the
@@ -14839,11 +14829,11 @@ end;
 
 @ @<Declare the procedure called |print_arg|@>=
 procedure print_arg(@!q:pointer;@!n:integer;@!b:pointer);
-begin if link(q)=void then print_nl("(EXPR")
+begin if link(q)=empty then print_nl("(EXPR")
 else if (b<text_base)and(b<>text_macro) then print_nl("(SUFFIX")
 else print_nl("(TEXT");
 print_int(n); print(")<-");
-if link(q)=void then print_exp(q,1)
+if link(q)=empty then print_exp(q,1)
 else show_token_list(q,null,1000,0);
 end;
 
@@ -15284,10 +15274,10 @@ A loop-control node also has two other fields, called |loop_type| and
 points to a list of one-word nodes whose |info| fields point to the
 remaining argument values of a suffix list and expression list.
 
-\yskip\indent|loop_type(loop_ptr)=void| means that the current loop is
+\yskip\indent|loop_type(loop_ptr)=empty| means that the current loop is
 `\&{forever}'.
 
-\yskip\indent|loop_type(loop_ptr)=p>void| means that |value(p)|,
+\yskip\indent|loop_type(loop_ptr)=p>empty| means that |value(p)|,
 |step_size(p)|, and |final_value(p)| contain the data for an arithmetic
 progression.
 
@@ -15337,7 +15327,7 @@ var @!m:halfword; {|expr_base| (\&{for}) or |suffix_base| (\&{forsuffixes})}
 @!p,@!q,@!s,@!pp:pointer; {link manipulation registers}
 begin m:=cur_mod; n:=cur_sym; s:=get_node(loop_node_size);
 if m=start_forever then
-  begin loop_type(s):=void; p:=null; get_x_next; goto found;
+  begin loop_type(s):=empty; p:=null; get_x_next; goto found;
   end;
 get_symbol; p:=get_node(token_node_size); info(p):=cur_sym; value(p):=m;@/
 get_x_next;
@@ -15391,13 +15381,13 @@ text(frozen_repeat_loop):=" ENDFOR";
 label not_found,exit;
 var @!p,@!q:pointer; {link registers}
 begin p:=loop_type(loop_ptr);
-if p>void then {|p| points to a progression node}
+if p>empty then {|p| points to a progression node}
   begin cur_exp:=value(p);
   if @<The arithmetic progression has ended@> then goto not_found;
   cur_type:=known; q:=stash_cur_exp; {make |q| an \&{expr} argument}
   value(p):=cur_exp+step_size(p); {set |value(p)| for the next iteration}
   end
-else if p<void then
+else if p<empty then
   begin p:=loop_list(loop_ptr);
   if p=null then goto not_found;
   loop_list(loop_ptr):=link(p); q:=info(p); free_avail(p);
@@ -15418,7 +15408,7 @@ exit:end;
 @ @<Trace the start of a loop@>=
 begin begin_diagnostic; print_nl("{loop value=");
 @.loop value=n@>
-if (q<>null)and(link(q)=void) then print_exp(q,1)
+if (q<>null)and(link(q)=empty) then print_exp(q,1)
 else show_token_list(q,null,50,0);
 print_char("}"); end_diagnostic(false);
 end
@@ -15430,13 +15420,13 @@ from the input stack.
 @p procedure stop_iteration;
 var @!p,@!q:pointer; {the usual}
 begin p:=loop_type(loop_ptr);
-if p>void then free_node(p,progression_node_size)
-else if p<void then
+if p>empty then free_node(p,progression_node_size)
+else if p<empty then
   begin q:=loop_list(loop_ptr);
   while q<>null do
     begin p:=info(q);
     if p<>null then
-      if link(p)=void then {it's an \&{expr} parameter}
+      if link(p)=empty then {it's an \&{expr} parameter}
         begin recycle_value(p); free_node(p,value_node_size);
         end
       else flush_token_list(p); {it's a \&{suffix} or \&{text} parameter}
@@ -16129,7 +16119,7 @@ are allowed.  Conversely, \MF\ has no variables of type |vacuous| or
 @ Capsules are two-word nodes that have a similar meaning
 to |cur_type| and |cur_exp|. Such nodes have |name_type=capsule|,
 and their |type| field is one of the possibilities for |cur_type| listed above.
-Also |link<=void| in capsules that aren't part of a token list.
+Also |link<=empty| in capsules that aren't part of a token list.
 
 The |value| field of a capsule is, in most cases, the value that
 corresponds to its |type|, as |cur_exp| corresponds to |cur_type|.
@@ -16157,7 +16147,7 @@ capsule. It is not used when |cur_type=token_list|.
 After the operation, |cur_type=vacuous|; hence there is no need to
 copy path lists or to update reference counts, etc.
 
-The special link |void| is put on the capsule returned by
+The special link |empty| is put on the capsule returned by
 |stash_cur_exp|, because this procedure is used to store macro parameters
 that must be easily distinguishable from token lists.
 
@@ -16171,7 +16161,7 @@ othercases begin  p:=get_node(value_node_size); name_type(p):=capsule;
   type(p):=cur_type; value(p):=cur_exp;
   end
 endcases;@/
-cur_type:=vacuous; link(p):=void; stash_cur_exp:=p;
+cur_type:=vacuous; link(p):=empty; stash_cur_exp:=p;
 end;
 
 @ The inverse of |stash_cur_exp| is the following procedure, which
@@ -16316,7 +16306,7 @@ begin if interaction=error_stop_mode then wake_up_terminal;
 print_nl(">> ");
 @.>>@>
 print_exp(p,1); {``medium verbose'' printing of the expression}
-if s<>"" then
+if interaction<>error_stop_mode then
   begin print_nl("! "); print(s);
 @.!\relax@>
   end;
@@ -18349,7 +18339,7 @@ that returns |null| if and only if its argument is not tarnished.
 @<Sidestep |independent| cases in capsule |p|@>=
 case type(p) of
 transform_type,pair_type: old_p:=tarnished(p);
-independent: old_p:=void;
+independent: old_p:=empty;
 othercases old_p:=null
 endcases;
 if old_p<>null then
@@ -18360,7 +18350,7 @@ if old_p<>null then
 @ @<Sidestep |independent| cases in the current expression@>=
 case cur_type of
 transform_type,pair_type:old_exp:=tarnished(cur_exp);
-independent:old_exp:=void;
+independent:old_exp:=empty;
 othercases old_exp:=null
 endcases;
 if old_exp<>null then
@@ -18375,7 +18365,7 @@ var @!q:pointer; {beginning of the big node}
 begin q:=value(p); r:=q+big_node_size[type(p)];
 repeat r:=r-2;
 if type(r)=independent then
-  begin tarnished:=void; return;
+  begin tarnished:=empty; return;
   end;
 until r=q;
 tarnished:=null;
@@ -18628,7 +18618,7 @@ begin if internal[tracing_commands]>two then
   @<Trace the fraction multiplication@>;
 case cur_type of
 transform_type,pair_type:old_exp:=tarnished(cur_exp);
-independent:old_exp:=void;
+independent:old_exp:=empty;
 othercases old_exp:=null
 endcases;
 if old_exp<>null then
@@ -19136,8 +19126,7 @@ if b>l then
   end;
 str_room(b-a);
 if reversed then
-  for k:=str_start[s]+b-1 downto str_start[s]+a do append_char(so(str_pool[k]))
-else for k:=str_start[s]+a to str_start[s]+b-1 do append_char(so(str_pool[k]));
+ for k:=str_start[s]+a to str_start[s]+b-1 do append_char(so(str_pool[k]));
 cur_exp:=make_string; delete_str_ref(s);
 end;
 
@@ -21206,7 +21195,7 @@ We may need to cancel skips that span more than 127 lig/kern steps.
 
 @d cancel_skips(#)==ll:=#;
   repeat lll:=qo(skip_byte(ll)); skip_byte(ll):=stop_flag; ll:=ll-lll;
-  until lll=0
+  until lll=0;
 @d skip_error(#)==begin print_err("Too far to skip");
 @.Too far to skip@>
   help1("At most 127 lig/kern steps can separate skipto1 from 1::.");
@@ -22343,7 +22332,7 @@ Several edges might cancel at the same column position, so we need to
 look ahead to column~|mm| before actually outputting anything.
 
 @<Output the pixels of edge row |p| to font row |n|@>=
-if unsorted(p)>void then sort_edges(p);
+if unsorted(p)>empty then sort_edges(p);
 q:=sorted(p); w:=0; prev_m:=-fraction_one; {$|fraction_one|\approx\infty$}
 ww:=0; prev_w:=0; m:=prev_m;
 repeat if q=sentinel then mm:=fraction_one
